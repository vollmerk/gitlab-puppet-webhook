#!/usr/bin/env python
# vim: set softtabstop=2 ts=2 sw=2 expandtab: 
#
# Copyright (c) 2015 Dalhousie University
# Copyright (c) 2015 Karl Vollmer (karl.vollmer@gmail.com)
#
# This code was based on and Inspired by https://github.com/shawn-sterling/gitlab-webhook-receiver 
# Copyright (C) 2012 Shawn Sterling <shawn@systemtemplar.org>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License v2
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

import os,subprocess,sys,stat
import ConfigParser
import logging,logging.handlers
import json
import daemon,daemon.pidfile
from pwd import getpwnam
from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer


## Define what our webserver is going to do
class puppetwebhook(BaseHTTPRequestHandler): 

  """
    log_message: disable output, everything is logged to file
  """
  def log_message(self,formate,*args):
    return

  """
    run_cmd: Runs a CLI command as a sub-proccess does our GIT commands
  """
  def run_cmd(self,cmd):
    log.debug('run_cmd:: %s' % cmd)
    """ Run the command, and then wait for it to finish """
    proc = subprocess.Popen(cmd.split(),stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
    proc.wait()
    """ Check for non zero return code, and log error """
    if proc.returncode != 0:
      log.critical('run_cmd:: Non-zero exit code:%s executing: %s' % (proc.returncode,cmd))
      log.critical('run_cmd:: %s',proc.stdout.read())
    else:
      log.info('run_cmd:: %s executed sucessfully',cmd)
      log.debug('run_cmd:: %s',proc.stdout.read())
    return proc.stdout

  """
    do_POST: Handles incoming post from gitlab webhook, decode json and do something about it
              for now we're just going to log it!
  """
  def do_POST(self):
    log.info('do_POST:: Received post, processing')

    """ Read in the json string """
    self.rfile._sock.settimeout(10)
    json_string = self.rfile.read(int(self.headers['Content-Length']))
    log.debug('do_POST:: Received Json String %s',json_string)

    """ We're going to say we're ok regardless of what actually happens """
    message = 'OK'
    self.send_response(200)
    self.send_header('Content-type','text')
    self.send_header('Content-length',str(len(message)))
    self.end_headers()
    self.wfile.write(message)
    log.debug('do_POST:: HTTP 200 sent to gitlab, connection should be closed')

    """ Parse received json """
    data = json.loads(json_string)

    """ Look for our defined puppet project in the json """
    if data['repository']['name'] == Config.get('main','project_name'):
      log.info('do_POST:: %s detected in JSON, processing',Config.get('main','project_name'))

      repoBranch = data['ref'].split('/')[2]

      """ Check the environment_method config option """
      if Config.get('main','environment_method') == 'repo':
        """ Make sure we're not dealing with a protected/prohibited user/env """
        repoBase = data['repository']['git_ssh_url'].split(':')[1].split('/')[0]
      elif Config.get('main','environment_method') == 'branch':
        repoBase = data['ref'].split('/')[2]
      else:
        log.info('do_POST:: Invalid envrionment_method in config file, doing nothing')
        return False

      """ Check to see if we're dealing with the production branch, defaults to master """
      if repoBranch == Config.get('main','production_environment'):
        repoBase = 'production'
      else:
        repoBase = repoBranch

      if repoBase in Config.get('main','protected_environments'):
        log.info('do_POST:: %s is a protected environment, halting',repoBase)
      else:
        """ Run the git pull, create dir if needed """
        log.info('do_POST:: %s is not a protected environment, syncing',repoBase)
        self.environment_sync(repoBase,data['repository']['git_ssh_url'],repoBranch)

    else:
      log.debug('do_POST:: %s not in JSON, ignoring',Config.get('main','project_name'))

  """
    environment_sync:: takes a project base and a SSH repo url, create directory and
     clone git repo if it doesn't exist, if it exists then just do a git pull
  """
  def environment_sync(self,environment,git_ssh_url,gitBranch):

    """ Check for path existance """
    if os.path.exists(os.path.join(Config.get('main','puppet_env_dir'),environment)):
      log.debug('environment_sync:: %s exists, doing git pull',os.path.join(Config.get('main','puppet_env_dir'),environment))
      """ Switch to the directory, so git pull acts like you'd expect - git bugs prevent out of path pulls """
      os.chdir(os.path.join(Config.get('main','puppet_env_dir'),environment))
      pullCmd = 'git pull -b %s' % (gitBranch)
      output = self.run_cmd(pullCmd)
    else:
      """ If it doesn't exist, ch to base and git clone it! """
      os.chdir(Config.get('main','puppet_env_dir'))
      log.info('environment_sync:: %s does not exist, cloning into new directory',environment)
      output = self.run_cmd('git clone -b %s %s %s' % (gitBranch,git_ssh_url,environment))


""" 
 Main:: Run it! 
"""
def main():
  """ Restart the Logger now that we've switched to the new UID """
  startLogger()
  
  """ Try to start HTTP server """
  try:
    server = HTTPServer(('',int(Config.get('main','http_port'))),puppetwebhook)
    log.info(':Main:: Starting HTTP Server on port %s',Config.get('main','http_port'))
    server.serve_forever()
  except KeyboardInterrupt,SystemExit:
    log.info(':Main:: Ctrl-C Detected, shutting down')
    server.socket.close()
  except:
    log.info(':Main:: HTPT Server start on TCP %s failed unknown error') % (Config.get('main','http_port'))
    server.socket.close()
    sys.exit(1)

"""
  startLogger
    Attempt to create and start a logging handle, log is globalized so that we can pass this around
"""
def startLogger():
  global log
  """
    Init Logging, use values from config we store 7 historical copies by
    default, maybe move that into the config?
  """
  if Config.get('main','log_level') == 'DEBUG':
    log_level = logging.DEBUG
  elif Config.get('main','log_level') == 'INFO':
    log_level = logging.INFO
  else:
    log_level = logging.WARNING
  try:
    log = logging.getLogger('log')
    log.setLevel(log_level)
    log_handle = logging.handlers.RotatingFileHandler(Config.get('main','log_file'),maxBytes=Config.get('main','log_max_size'),backupCount=7)
    log_format = logging.Formatter("%(asctime)s %(levelname)s %(message)s","%B %d %H:%M:%S")
    log_handle.setFormatter(log_format)
    log.addHandler(log_handle)
  except IOError:
    print ':Main:: IOError opening %s verify permissions' % (Config.get('main','log_file'))
    sys.exit(1)
 

if __name__ == '__main__':
  global Config
  """ Load the Config file ./webhook-puppet.conf """
  Config = ConfigParser.ConfigParser()
  try:
    Config.read(os.path.dirname(os.path.abspath(__file__)) + '/webhook-puppet.conf')
  except IOError:
    print ':Main:: IOError opening %s verify permissions' % (os.path.dirname(os.path.abspath(__file__)) + '/webhook-puppet.conf')
    sys.exit(1)

  daemonuid = getpwnam(Config.get('main','runas')).pw_uid
  daemongid = getpwnam(Config.get('main','runas')).pw_gid
  if daemongid == 0 or daemonuid == 0:
    print 'Aborting:: service cannot run as ROOT'
    sys.exit(1)

  """ Config and log must be global """
  startLogger()


  """ python-daemon doesn't gracefully handle the pid lock file not being writeable so check manually """
  dirStat = os.stat(os.path.dirname(os.path.abspath(__file__)))
  if ((dirStat[stat.ST_UID] != daemonuid and (dirStat[stat.ST_MODE] & stat.S_IWUSR)) or
    (dirStat[stat.ST_GID] != daemongid and (dirStat[stat.ST_MODE] & stat.S_IWGRP)) or
    (dirStat[stat.ST_MODE] & stat.S_IWOTH)):
    print ':Main:: IOError unable to write lockfile %s' % (os.path.dirname(os.path.abspath(__file__)) + '/gitlab-puppet-webhook.pid')
    sys.exit(1)

  try:
    log.debug('Starting Daemon as %s (%s:%s)' % (Config.get('main','runas'),daemonuid,daemongid))
    logging.shutdown()
    with daemon.DaemonContext(
      pidfile=daemon.pidfile.PIDLockFile(os.path.dirname(os.path.abspath(__file__)) + '/gitlab-puppet-webhook.pid'),
      uid=daemonuid,
      gid=daemongid
    ):
      main()
  except:
    print ':Main:: Unknown Error starting daemon!'
    raise
