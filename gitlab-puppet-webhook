#!/usr/bin/env python
# vim: set softtabstop=2 ts=2 sw=2 expandtab: 
#
# Copyright (c) 2015 Dalhousie University
# Copyright (c) 2015 Karl Vollmer (karl.vollmer@gmail.com)
#
# This code was based on and Inspired by https://github.com/shawn-sterling/gitlab-webhook-receiver 
# Copyright (C) 2012 Shawn Sterling <shawn@systemtemplar.org>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License v2
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

import os,subprocess,sys,stat,re
import ConfigParser
import logging,logging.handlers
import json
import daemon,daemon.pidfile
import ssl
import smtplib
from email import message
from pwd import getpwnam
from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer


## Define what our webserver is going to do
class puppetwebhook(BaseHTTPRequestHandler): 

  """
    log_message: disable output, everything is logged to file
  """
  def log_message(self,formate,*args):
    return

  def sendEmail(self,sender,receivers,message):
    try:
      smtpObj = smtplib.SMTP(Config.get('email','smtpserver'))
      smtpObj.sendmail(sender,receivers,message)
      log.info('sendEmail:: Send E-mail to %s from %s Body:\n%s' % (receivers,sender,message))
    except SMTPException:
      log.critical('sendEmail:: Failed to send e-mail via %s to %s from %s' % (Config.get('main','smtpserver'),receivers,sender))
      return False
    return True

  """
    run_cmd: Runs a CLI command as a sub-proccess does our GIT commands
  """
  def run_cmd(self,cmd):
    """ Make sure git looks in the right homedir """
    os.environ['HOME'] = os.path.expanduser('~' + Config.get('main','runas'))
    log.debug('run_cmd:: %s' % cmd)
    """ Run the command, and then wait for it to finish """
    proc = subprocess.Popen(cmd.split(),stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
    proc.wait()
    """ Check for non zero return code, and log error """
    if proc.returncode != 0:
      log.info('run_cmd:: Non-zero exit code:%s executing: %s' % (proc.returncode,cmd))
      log.info('run_cmd:: %s',proc.stdout.read())
      return False
    else:
      log.info('run_cmd:: %s executed sucessfully',cmd)
      log.debug('run_cmd:: %s',proc.stdout.read())
    return proc.stdout

  """
    do_POST: Handles incoming post from gitlab webhook, decode json and do something about it
              for now we're just going to log it!
  """
  def do_POST(self):
    log.info('do_POST:: Received post, processing')

    """ Read in the json string """
    self.rfile._sock.settimeout(10)
    json_string = self.rfile.read(int(self.headers['Content-Length']))

    """ Check for the secret_token config, if specified check X-Gitlab-Token header """
    secret = False
    try:
      secret = Config.get('main','secret_token')
    except:
      log.debug('do_POST:: No secret token defined, accepting incoming post')

    if secret:
      if secret != self.headers['X-Gitlab-Token']:
        log.debug('do_POST:: Secret %s does not match X-Gitlab-Token %s ignoring post' % (secret,self.headers['X-Gitlab-Token']))
        return False
      else:
        log.debug('do_POST:: Secret and X-Gitlab-Token match accepting post')

    log.debug('do_POST:: Received Json String %s',json_string)

    """ We're going to say we're ok regardless of what actually happens """
    message = 'OK'
    self.send_response(200)
    self.send_header('Content-type','text')
    self.send_header('Content-length',str(len(message)))
    self.end_headers()
    self.wfile.write(message)
    log.debug('do_POST:: HTTP 200 sent to gitlab, connection should be closed')

    """ Parse received json """
    data = json.loads(json_string)

    """ Look for our defined puppet project in the json """
    if data['repository']['name'] == Config.get('main','project_name'):
      log.info('do_POST:: %s detected in JSON starting processing',Config.get('main','project_name'))

      try: 
        repoBranch = data['ref'].split('/')[2]
      except:
        log.info('do_POST:: Unable to determine branch aborting post')
        return False

      """ Check the environment_method config option """
      try:
        method = Config.get('main','environment_method')
      except:
        log.debug('do_POST:: Invalid Config(main,environment_method) defaulting to repo')
        method = 'repo'

      if method == 'repo':
        """ Make sure we're not dealing with a protected/prohibited user/env """
        try:
          repoBase = data['repository']['git_ssh_url'].split(':')[1].split('/')[0]
        except:
          log.debug('Invalid Git SSH Url in payload unable to determine repoBase %s' % (data['repository']['git_ssh_url']))
      elif method == 'branch':
        try:
          repoBase = data['ref'].split('/')[2]
        except:
          log.debug('Invalid reference, unable to split and determine repoBase %s' % (data['ref']))
      else:
        log.info('do_POST:: Invalid envrionment_method in config file, doing nothing')
        return False

      log.debug('do_POST:: Branch [%s] being cloned into %s' % (repoBranch,repoBase))

      if method == 'branch':
        """ If we're on the production branch, reset repoBase to production """
        if repoBranch == Config.get('main','production_environment'):
          repoBase = 'production'
        else:
          repoBase = repoBranch
      elif method == 'repo':
        """ Check the repoBase for production_environment matching """
        if repoBase == Config.get('main','production_environment'):
          repoBase = 'production'
      else:
        log.critical('do_POST:: Invalid environment_method specified doing nothing')
        return False

      if repoBase in Config.get('main','protected_environments'):
        log.info('do_POST:: %s is a protected environment, halting',repoBase)
      else:
        """ Run the git pull, create dir if needed """
        log.info('do_POST:: %s is not a protected environment, syncing',repoBase)
        self.environmentSync(repoBase,data['repository']['git_ssh_url'],repoBranch)
        self.sendTicketSystem(data,repoBranch,repoBase)

    else:
      log.debug('do_POST:: %s not in JSON, ignoring',Config.get('main','project_name'))

  def sendTicketSystem(self,data,repoBranch,repoBase):
    """ Send e-mail based on method, and configured ticket system modules """
    if Config.get('email','method') == 'production' and repoBase != 'production':
      log.debug('sendTicketSystem:: repoBase not production not e-mailing to ticket system(s)')
      return False
    elif Config.get('email','method') == 'development' and repoBase == 'production':
      log.debug('sendTicketSystem:: repoBase is production, method is development not e-mailing')
      return False

    """ Do reg-exp to try to find the #[foo] in commit message """
    for commit in data['commits']:
      log.debug('sendTicketSystem:: found a commit checking for #\d+')
      for ticketnumber in re.findall('#(\d+)',commit['message']):
        log.debug('sendTicketSystem:: found %s ticket number in commit proccessing',ticketnumber)
        commands = ''
        """ Try to use the author's e-mail address """
        try:
          sender = '"'+commit['author']['name']+'" <' +commit['author']['email'] + '>'
        except:
          sender = Config.get('email','from')
        if Config.get('footprints','enabled').lower() != 'false':
          """ Footprints isn't disabled, send out an e-mail """
          log.debug('footprintsEmail:: enabled proccessing')
          self.footprintsEmail(sender,ticketnumber,commit)
        else: 
          log.debug('footprintsEmail:: disabled, not sending')
        if Config.get('otrs','enabled').lower() != 'false':
          """ OTRS isn't disabled, send out an e-mail """
          log.debug('otrsEmail:: enabled proccessing')
          self.otrsEmail(sender,ticketnumber,commit)
        else:
          log.debug('otrsEmail:: disabled not sending')
     
    return True


  """ 
   otrsEmail:: If otrs is enabled in teh config then attempt to send an 
   agent internal-note update to the ticket in question
  """
  def otrsEmail(self,sender,ticketnumber,commit):
    log.debug('otrsEmail:: starting proccessing')
    otrsmsg = message.Message()
    otrsmsg.add_header('X-OTRS-FollowUp-SenderType','agent')
    otrsmsg.add_header('X-OTRS-FollowUp-ArticleType','note-internal')
    REfixed = re.compile('.*fix[ed]?\s*#' + ticketnumber,re.MULTILINE|re.IGNORECASE)
    if REfixed.search(commit['message']):
      log.debug('otrsEmail:: found FIX #\d+ in commit triggering close')
      otrsmsg.add_header('X-OTRS-FollowUp-State','closed successful')
    otrsmsg.set_payload(commit['message'] + "\n" + commit['url'])
    otrsmsg.add_header('subject','GITLAB-Push Update [Ticket#' + ticketnumber + ']')
    otrsmsg.add_header('from',sender)
    log.info('otrsEmail:: Sending E-mail to %s with subject %s' % (Config.get('otrs','to'),otrsmsg.as_string()))
    self.sendEmail(sender,Config.get('otrs','to'),otrsmsg.as_string())

    return True

  """
   footprintsEmail:: If footprints is enabled in the config then attempt to send
   and update e-mail to footprints based on the ticket info
  """
  def footprintsEmail(self,sender,ticketnumber,commit):
    log.debug('footprintsEmail:: starting proccessing')
    commands = None
    time = re.compile('.*(Time=\d+[mh]{1}(\s{1}\d+[m]{1})?).*',re.IGNORECASE)
    REfixed = re.compile('.*fix[ed]?\s*#' + ticketnumber,re.MULTILINE|re.IGNORECASE)
    """ Check for FIX right before #"""
    if REfixed.search(commit['message']):
      log.debug('footprintsEmail:: found FIX #\d+ in commit triggering close')
      commands = 'Status=' + Config.get('footprints','close_status') + "\n"
    """ See if we had some time """
    if time.search(commit['message']):
      log.debug('sendticketSystem:: found Time string as %s', time.group(1))
      commands = commands + time.group(1) + "\n"
    body = commands + "\n" + commit['message'] + "\n" + commit['url']
    subject = 'GITLAB-Push Update ISSUE=' + ticketnumber + ' PROJ=' + Config.get('footprints','project')
    message = "From: %s\nSubject: %s\n%s" % (sender,subject,body)
    log.info('footprintsEmail:: Sending E-mail to %s with subject %s'% (Config.get('footprints','to'),subject))
    self.sendEmail(sender,Config.get('footprints','to'),message)

    return True

  """
    environmentSync:: takes a project base and a SSH repo url, create directory and
     clone git repo if it doesn't exist, if it exists then just do a git pull
  """
  def environmentSync(self,environment,git_ssh_url,gitBranch):

    """ Run R10K to re-sync the environments and modules """
    r10kcmd = 'r10k deploy environment --puppetfile -c %s' % (Config.get('r10k','config'))
    try:
      os.chdir(Config.get('main','puppet_env_dir'))
      self.run_cmd(r10kcmd)
    except:
      log.info('Unable to run r10k deploy, environments not updated')

    """ Check and see if legacy is enabled """
    if Config.get('legacy','enabled') == 'true':
      log.debug('environment_sync:: Legacy Enabled, checking monolithic modules out to %s' % (Config.get('legacy','path')))
      if os.path.exists(os.path.join(Config.get('main','puppet_env_dir'),environment,Config.get('legacy','path'))):
        os.chdir(os.path.join(Config.get('main','puppet_env_dir'),environment,Config.get('legacy','path')))
        """ Check the repo out into the current directory """
        checkoutCmd = 'git checkout production .'
        output = self.run_cmd(checkoutCmd)
        if output == False:
          """ If checkout fails, clone """
          self.run_cmd('git clone -b production %s .' % (Config.get('legacy','gitpath')))
        pullCmd = 'git pull'
        output = self.run-cmd(pullCmd)
      else:
        """ If it doesn't exist, ch to base and git clone it! """
        os.chdir(os.path.join(Config.get('main','puppet_env_dir'),environment))
        log.info('environment_sync:: %s/%s does not exist, cloning into new directory' % (environment,Config.get('legacy','path')))
        output = self.run_cmd('git clone -b %s %s %s' % (gitBranch,git_ssh_url,Config.get('legacy','path')))


""" 
 Main:: Run it! 
"""
def runLaunch():
  """ Restart the Logger now that we've switched to the new UID """
  startLogger()
  
  server = HTTPServer(('',int(Config.get('main','http_port'))),puppetwebhook)
  """ Try to start HTTP server """
  try:
    server.socket = ssl.wrap_socket(server.socket,certfile=Config.get('main','ssl_certfile'),server_side=True)
  except: 
    log.info(':Main:: Error creating SSL socket')

  try:
    server.serve_forever()
    log.info(':Main:: Starting HTTP Server on port %s',Config.get('main','http_port'))
    """ DEBUG Log current settings """
    log.debug(':Main:: Config.environment_method [%s]',Config.get('main','environment_method'))
    log.debug(':Main:: Config.production_environment [%s]',Config.get('main','production_environment'))
    log.debug(':Main:: Config.project_name [%s]',Config.get('main','project_name'))
    log.debug(':Main:: Config.log_file [%s]',Config.get('main','log_file'))
    log.debug(':Main:: Config.runas [%s]',Config.get('main','runas'))
  except KeyboardInterrupt,SystemExit:
    log.info(':Main:: Ctrl-C Detected, shutting down')
    server.socket.close()
  except:
    log.info(':Main:: HTTP servers shutting down')
    server.socket.close()
    sys.exit(1)

"""
  startLogger
    Attempt to create and start a logging handle, log is globalized so that we can pass this around
"""
def startLogger():
  global log

  """
    Init Logging, use values from config we store 7 historical copies by
    default, maybe move that into the config?
  """
  if Config.get('main','log_level') == 'DEBUG':
    log_level = logging.DEBUG
  elif Config.get('main','log_level') == 'INFO':
    log_level = logging.INFO
  else:
    log_level = logging.WARNING
  try:
    log = logging.getLogger('log')
    """ If we already have log handlers, don't re-create """
    if len(log.handlers):
      return True
    log.setLevel(log_level)
    log_handle = logging.handlers.RotatingFileHandler(Config.get('main','log_file'),maxBytes=Config.get('main','log_max_size'),backupCount=7)
    log_format = logging.Formatter("%(asctime)s %(levelname)s %(message)s","%B %d %H:%M:%S")
    log_handle.setFormatter(log_format)
    log.addHandler(log_handle)
  except IOError:
    print ':Main:: IOError opening %s verify permissions' % (Config.get('main','log_file'))
    sys.exit(1)
 
if __name__ == '__main__':
  global Config
  """ Load the Config file ./webhook-puppet.conf """
  Config = ConfigParser.ConfigParser()
  try:
    Config.read(os.path.dirname(os.path.abspath(__file__)) + '/webhook-puppet.conf')
  except IOError:
    print ':Main:: IOError opening %s verify permissions' % (os.path.dirname(os.path.abspath(__file__)) + '/webhook-puppet.conf')
    sys.exit(1)

  daemonuid = getpwnam(Config.get('main','runas')).pw_uid
  daemongid = getpwnam(Config.get('main','runas')).pw_gid
  if daemongid == 0 or daemonuid == 0:
    print 'Aborting:: service cannot run as ROOT'
    sys.exit(1)

  """ Config and log must be global """
  startLogger()


  """ python-daemon doesn't gracefully handle the pid lock file not being writeable so check manually """
  dirStat = os.stat(os.path.dirname(os.path.abspath(__file__)))
  if ((dirStat[stat.ST_UID] != daemonuid and (dirStat[stat.ST_MODE] & stat.S_IWUSR)) or
    (dirStat[stat.ST_GID] != daemongid and (dirStat[stat.ST_MODE] & stat.S_IWGRP)) or
    (dirStat[stat.ST_MODE] & stat.S_IWOTH)):
    print ':Main:: IOError unable to write lockfile %s' % (os.path.dirname(os.path.abspath(__file__)) + '/gitlab-puppet-webhook.pid')
    sys.exit(1)

  try:
    log.debug('Starting Daemon as %s (%s:%s)' % (Config.get('main','runas'),daemonuid,daemongid))
    logging.shutdown()
    with daemon.DaemonContext(
      pidfile=daemon.pidfile.PIDLockFile(os.path.dirname(os.path.abspath(__file__)) + '/gitlab-puppet-webhook.pid'),
      uid=daemonuid,
      gid=daemongid
    ):
      runLaunch()
  except:
    print ':Main:: Unknown Error starting daemon!'
    raise
